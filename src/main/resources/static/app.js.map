{
  "version": 3,
  "sources": ["../../frontend/node_modules/@github/webauthn-json/src/webauthn-json/base64url.ts", "../../frontend/node_modules/@github/webauthn-json/src/webauthn-json/convert.ts", "../../frontend/node_modules/@github/webauthn-json/src/webauthn-json/basic/schema.ts", "../../frontend/node_modules/@github/webauthn-json/src/webauthn-json/basic/api.ts", "../../frontend/node_modules/@github/webauthn-json/src/webauthn-json/basic/supported.ts", "../../frontend/node_modules/@github/webauthn-json/src/webauthn-json/browser-ponyfill.ts", "../../frontend/app.js"],
  "sourcesContent": ["export type Base64urlString = string;\n\nexport function base64urlToBuffer(\n  baseurl64String: Base64urlString,\n): ArrayBuffer {\n  // Base64url to Base64\n  const padding = \"==\".slice(0, (4 - (baseurl64String.length % 4)) % 4);\n  const base64String =\n    baseurl64String.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n\n  // Base64 to binary string\n  const str = atob(base64String);\n\n  // Binary string to buffer\n  const buffer = new ArrayBuffer(str.length);\n  const byteView = new Uint8Array(buffer);\n  for (let i = 0; i < str.length; i++) {\n    byteView[i] = str.charCodeAt(i);\n  }\n  return buffer;\n}\n\nexport function bufferToBase64url(buffer: ArrayBuffer): Base64urlString {\n  // Buffer to binary string\n  const byteView = new Uint8Array(buffer);\n  let str = \"\";\n  for (const charCode of byteView) {\n    str += String.fromCharCode(charCode);\n  }\n\n  // Binary string to base64\n  const base64String = btoa(str);\n\n  // Base64 to base64url\n  // We assume that the base64url string is well-formed.\n  const base64urlString = base64String.replace(/\\+/g, \"-\").replace(\n    /\\//g,\n    \"_\",\n  ).replace(/=/g, \"\");\n  return base64urlString;\n}\n", "// We export these values in order so that they can be used to deduplicate\n// schema definitions in minified JS code.\n\nimport { Schema, SchemaProperty } from \"./schema-format\";\n\n// TODO: Parcel isn't deduplicating these values.\nexport const copyValue = \"copy\";\nexport const convertValue = \"convert\";\n\nexport function convert<From, To>(\n  conversionFn: (v: From) => To,\n  schema: Schema,\n  input: any,\n): any {\n  if (schema === copyValue) {\n    return input;\n  }\n  if (schema === convertValue) {\n    return conversionFn(input);\n  }\n  if (schema instanceof Array) {\n    return input.map((v: any) => convert<From, To>(conversionFn, schema[0], v));\n  }\n  if (schema instanceof Object) {\n    const output: any = {};\n    for (const [key, schemaField] of Object.entries(schema)) {\n      if (schemaField.derive) {\n        const v = schemaField.derive(input);\n        if (v !== undefined) {\n          input[key] = v;\n        }\n      }\n\n      if (!(key in input)) {\n        if (schemaField.required) {\n          throw new Error(`Missing key: ${key}`);\n        }\n        continue;\n      }\n      // Fields can be null (rather than missing or `undefined`), e.g. the\n      // `userHandle` field of the `AuthenticatorAssertionResponse`:\n      // https://www.w3.org/TR/webauthn/#iface-authenticatorassertionresponse\n      if (input[key] == null) {\n        output[key] = null;\n        continue;\n      }\n      output[key] = convert<From, To>(\n        conversionFn,\n        schemaField.schema,\n        input[key],\n      );\n    }\n    return output;\n  }\n}\n\nexport function derived(\n  schema: Schema,\n  derive: (v: any) => any,\n): SchemaProperty {\n  return {\n    required: true,\n    schema,\n    derive,\n  };\n}\n\nexport function required(schema: Schema): SchemaProperty {\n  return {\n    required: true,\n    schema,\n  };\n}\n\nexport function optional(schema: Schema): SchemaProperty {\n  return {\n    required: false,\n    schema,\n  };\n}\n", "import { Schema } from \"../schema-format\";\nimport {\n  convertValue as convert,\n  copyValue as copy,\n  derived,\n  optional,\n  required,\n} from \"../convert\";\n\n// Shared by `create()` and `get()`.\n\nconst publicKeyCredentialDescriptorSchema: Schema = {\n  type: required(copy),\n  id: required(convert),\n  transports: optional(copy),\n};\n\nconst simplifiedExtensionsSchema: Schema = {\n  appid: optional(copy),\n  appidExclude: optional(copy),\n  credProps: optional(copy),\n};\n\nconst simplifiedClientExtensionResultsSchema = {\n  appid: optional(copy),\n  appidExclude: optional(copy),\n  credProps: optional(copy),\n};\n\n// `navigator.create()` request\n\nexport const credentialCreationOptions: Schema = {\n  publicKey: required({\n    rp: required(copy),\n    user: required({\n      id: required(convert),\n      name: required(copy),\n      displayName: required(copy),\n    }),\n\n    challenge: required(convert),\n    pubKeyCredParams: required(copy),\n\n    timeout: optional(copy),\n    excludeCredentials: optional([publicKeyCredentialDescriptorSchema]),\n    authenticatorSelection: optional(copy),\n    attestation: optional(copy),\n    extensions: optional(simplifiedExtensionsSchema),\n  }),\n  signal: optional(copy),\n};\n\n// `navigator.create()` response\n\nexport const publicKeyCredentialWithAttestation: Schema = {\n  type: required(copy),\n  id: required(copy),\n  rawId: required(convert),\n  authenticatorAttachment: optional(copy),\n  response: required({\n    clientDataJSON: required(convert),\n    attestationObject: required(convert),\n    transports: derived(\n      copy,\n      (response: any) => response.getTransports?.() || [],\n    ),\n  }),\n  clientExtensionResults: derived(\n    simplifiedClientExtensionResultsSchema,\n    (pkc: PublicKeyCredential) => pkc.getClientExtensionResults(),\n  ),\n};\n\n// `navigator.get()` request\n\nexport const credentialRequestOptions: Schema = {\n  mediation: optional(copy),\n  publicKey: required({\n    challenge: required(convert),\n    timeout: optional(copy),\n    rpId: optional(copy),\n    allowCredentials: optional([publicKeyCredentialDescriptorSchema]),\n    userVerification: optional(copy),\n    extensions: optional(simplifiedExtensionsSchema),\n  }),\n  signal: optional(copy),\n};\n\n// `navigator.get()` response\n\nexport const publicKeyCredentialWithAssertion: Schema = {\n  type: required(copy),\n  id: required(copy),\n  rawId: required(convert),\n  authenticatorAttachment: optional(copy),\n  response: required({\n    clientDataJSON: required(convert),\n    authenticatorData: required(convert),\n    signature: required(convert),\n    userHandle: required(convert),\n  }),\n  clientExtensionResults: derived(\n    simplifiedClientExtensionResultsSchema,\n    (pkc: PublicKeyCredential) => pkc.getClientExtensionResults(),\n  ),\n};\n\nexport const schema: { [s: string]: Schema } = {\n  credentialCreationOptions,\n  publicKeyCredentialWithAttestation,\n  credentialRequestOptions,\n  publicKeyCredentialWithAssertion,\n};\n", "import { base64urlToBuffer, bufferToBase64url } from \"../base64url\";\nimport { convert } from \"../convert\";\nimport {\n  CredentialCreationOptionsJSON,\n  CredentialRequestOptionsJSON,\n  PublicKeyCredentialWithAssertionJSON,\n  PublicKeyCredentialWithAttestationJSON,\n} from \"./json\";\nimport {\n  credentialCreationOptions,\n  credentialRequestOptions,\n  publicKeyCredentialWithAssertion,\n  publicKeyCredentialWithAttestation,\n} from \"./schema\";\n\nexport function createRequestFromJSON(\n  requestJSON: CredentialCreationOptionsJSON,\n): CredentialCreationOptions {\n  return convert(base64urlToBuffer, credentialCreationOptions, requestJSON);\n}\n\nexport function createResponseToJSON(\n  credential: PublicKeyCredential,\n): PublicKeyCredentialWithAttestationJSON {\n  return convert(\n    bufferToBase64url,\n    publicKeyCredentialWithAttestation,\n    credential,\n  );\n}\n\nexport async function create(\n  requestJSON: CredentialCreationOptionsJSON,\n): Promise<PublicKeyCredentialWithAttestationJSON> {\n  const credential = (await navigator.credentials.create(\n    createRequestFromJSON(requestJSON),\n  )) as PublicKeyCredential;\n  return createResponseToJSON(credential);\n}\n\nexport function getRequestFromJSON(\n  requestJSON: CredentialRequestOptionsJSON,\n): CredentialRequestOptions {\n  return convert(base64urlToBuffer, credentialRequestOptions, requestJSON);\n}\n\nexport function getResponseToJSON(\n  credential: PublicKeyCredential,\n): PublicKeyCredentialWithAssertionJSON {\n  return convert(\n    bufferToBase64url,\n    publicKeyCredentialWithAssertion,\n    credential,\n  );\n}\n\nexport async function get(\n  requestJSON: CredentialRequestOptionsJSON,\n): Promise<PublicKeyCredentialWithAssertionJSON> {\n  const credential = (await navigator.credentials.get(\n    getRequestFromJSON(requestJSON),\n  )) as PublicKeyCredential;\n  return getResponseToJSON(credential);\n}\n\ndeclare global {\n  interface Window {\n    PublicKeyCredential: PublicKeyCredential | undefined;\n  }\n}\n", "// This function does a simple check to test for the credential management API\n// functions we need, and an indication of public key credential authentication\n// support.\n// https://developers.google.com/web/updates/2018/03/webauthn-credential-management\n\nexport function supported(): boolean {\n  // rome-ignore format: Work around https://github.com/rome/tools/issues/3734\n  return !!(\n    // rome-ignore lint(style/useOptionalChain): Optional chaining creates more complicated ES2019 code\n    navigator.credentials &&\n    navigator.credentials.create &&\n    navigator.credentials.get &&\n    window.PublicKeyCredential\n  );\n}\n", "import {\n  createRequestFromJSON as parseCreationOptionsFromJSON,\n  createResponseToJSON,\n  getRequestFromJSON as parseRequestOptionsFromJSON,\n  getResponseToJSON,\n} from \"./basic/api\";\nimport { supported } from \"./basic/supported\";\n\nimport {\n  CredentialCreationOptionsJSON,\n  CredentialRequestOptionsJSON,\n  PublicKeyCredentialWithAssertionJSON as AuthenticationResponseJSON,\n  PublicKeyCredentialWithAttestationJSON as RegistrationResponseJSON,\n} from \"./basic/json\";\n\nexport { parseCreationOptionsFromJSON, parseRequestOptionsFromJSON, supported };\nexport type {\n  CredentialCreationOptionsJSON,\n  CredentialRequestOptionsJSON,\n  AuthenticationResponseJSON,\n  RegistrationResponseJSON,\n};\n\nexport interface RegistrationPublicKeyCredential extends PublicKeyCredential {\n  toJSON(): RegistrationResponseJSON;\n}\n\nexport async function create(\n  options: CredentialCreationOptions,\n): Promise<RegistrationPublicKeyCredential> {\n  const response = (await navigator.credentials.create(\n    options,\n  )) as RegistrationPublicKeyCredential;\n  response.toJSON = () => createResponseToJSON(response);\n  return response;\n}\n\nexport interface AuthenticationPublicKeyCredential extends PublicKeyCredential {\n  toJSON(): AuthenticationResponseJSON;\n}\n\nexport async function get(\n  options: CredentialRequestOptions,\n): Promise<AuthenticationPublicKeyCredential> {\n  const response = (await navigator.credentials.get(\n    options,\n  )) as AuthenticationPublicKeyCredential;\n  response.toJSON = () => getResponseToJSON(response);\n  return response;\n}\n", "import {create, parseCreationOptionsFromJSON, supported} from \"@github/webauthn-json/browser-ponyfill\";\r\n\r\nasync function generatePasskey() {\r\n    const creationOptionsTextarea = document.getElementById(\"creation-options\");\r\n    // const credentialCreateOptions = creationOptionsTextarea.value;\r\n\r\n    const username = document.getElementById(\"username\").value;\r\n    const displayName = document.getElementById(\"displayName\").value;\r\n    const publicKeyCredential = await getPublicKeyCredential(username, displayName);\r\n\r\n    creationOptionsTextarea.value = JSON.stringify(publicKeyCredential);\r\n    // Return encoded PublicKeyCredential to server\r\n    const registerResponse = await fetchPostAsJson(\"/register-credential\", JSON.stringify(publicKeyCredential));\r\n\r\n    creationOptionsTextarea.value += \"\\n\\n\\n\" + JSON.stringify(registerResponse);\r\n}\r\n\r\nasync function getPublicKeyCredential(name, displayName) {\r\n    if (sessionStorage.getItem(\"publicKeyCredential\")) {\r\n        return JSON.parse(sessionStorage.getItem(\"publicKeyCredential\"));\r\n    }\r\n\r\n    // Make the call that returns the credentialCreateJson above\r\n    const credentialCreateOptions = await fetchPostAsJson(\r\n        \"/create-credential\",\r\n        JSON.stringify({name, displayName})\r\n    );\r\n\r\n    // Call WebAuthn ceremony using webauthn-json wrapper\r\n    const cco = parseCreationOptionsFromJSON(credentialCreateOptions.publicKeyCredentialCreationOptions);\r\n    const publicKeyCredential = await create(cco);\r\n\r\n    const cachedCredential = publicKeyCredential.toJSON();\r\n    sessionStorage.setItem(\"publicKeyCredential\", JSON.stringify(cachedCredential));\r\n    return cachedCredential;\r\n}\r\n\r\nfunction fetchPostAsJson(input, body) {\r\n    return fetch(input, {\r\n        method: \"POST\",\r\n        body: body,\r\n        headers: {\"Content-Type\": \"application/json\"}\r\n    }).then(resp => resp.json());\r\n}\r\n\r\nwindow.addEventListener(\"load\", () => {\r\n    document.getElementById(\"generate-passkey\").addEventListener(\"click\", generatePasskey)\r\n});"],
  "mappings": "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",
  "names": []
}
